================================================================================
GSP (GENERALIZED SEQUENTIAL PATTERNS) - Complete Study Guide
================================================================================

ALGORITHM TYPE: Sequential Pattern Mining (Apriori-like for sequences)
PURPOSE: Extract frequent sequences from sequential databases

================================================================================
1. DEFINITION & PURPOSE
================================================================================

GSP mines frequent sequences from sequential databases. Unlike itemsets which 
are unordered, sequences maintain ORDER and timing information.

SEQUENCE:
An ordered list of itemsets: <(I₁)(I₂)(I₃)...>
- Order matters: <(A)(B)> ≠ <(B)(A)>
- Can have multiple items per element: <(AB)(C)(DE)>

SUBSEQUENCE:
S' is a subsequence of S if S' can be obtained by deleting some items/itemsets 
from S while maintaining ORDER.

Example: <(A)(C)> is subsequence of <(A)(B)(C)>
         Can skip (B), order preserved

================================================================================
2. KEY CONCEPTS
================================================================================

SEQUENCE NOTATION:
<(A)(B)(C)>     → Simple sequence: A, then B, then C
<(AB)(C)(D)>    → First itemset has A and B together
<A(BC)D>        → Shorthand for <(A)(BC)(D)>

ELEMENT:
Each parenthesized group in a sequence
Example: <(AB)(C)(DE)> has 3 elements

SUPPORT:
Number of sequences in database that CONTAIN the pattern as a subsequence
(divided by total sequences for relative support)

CONTAINMENT:
Sequence S contains subsequence S' if:
- All itemsets of S' appear in S in the same order
- Can skip items/itemsets in between

================================================================================
3. ALGORITHM STEPS (Similar to Apriori)
================================================================================

Step 1: FIND FREQUENT 1-SEQUENCES
   → Scan database, count individual items
   → Keep items with support ≥ min_sup
   → L₁ = frequent 1-sequences

Step 2: GENERATE CANDIDATE k-SEQUENCES
   → Join Lₖ₋₁ with Lₖ₋₁ to generate Cₖ
   → Two types of joins:
     a) Append to last element: <(A)(B)> + <(B)(C)> → <(A)(BC)>
     b) Create new element: <(A)(B)> + <(B)(C)> → <(A)(B)(C)>

Step 3: PRUNE CANDIDATES
   → For each candidate in Cₖ:
     - Check if ALL (k-1)-subsequences are in Lₖ₋₁
     - If any is missing, remove candidate (anti-monotone property)

Step 4: COUNT SUPPORT
   → For each sequence in database:
     - Check if it contains each candidate
     - Count number of sequences containing each candidate

Step 5: GENERATE FREQUENT k-SEQUENCES
   → Keep only candidates with support ≥ min_sup
   → These become Lₖ

Step 6: REPEAT
   → Repeat steps 2-5 until no more candidates

Step 7: OUTPUT
   → Return L = L₁ ∪ L₂ ∪ ... ∪ Lₖ

================================================================================
4. COMPLETE EXAMPLE (from Exam 2019-2020)
================================================================================

Given Sequential Database:
Sequence ID | Sequence
------------|-------------------
S1          | <C A G A A G T>
S2          | <G A A G T>
S3          | <T G A C A G>

min_sup = 3

SOLUTION STEP-BY-STEP:

STEP 1: Find Frequent 1-Sequences (L₁)
----------------------------------------
Count each item:
A: appears in S1, S2, S3 → support = 3 ✓
C: appears in S1, S3 → support = 2 ✗
G: appears in S1, S2, S3 → support = 3 ✓
T: appears in S1, S2, S3 → support = 3 ✓

L₁ = {<A>:3, <G>:3, <T>:3}

STEP 2: Generate Candidate 2-Sequences (C₂)
--------------------------------------------
Join L₁ with L₁:
Possible 2-sequences:
<AA>, <AG>, <AT>, <GA>, <GG>, <GT>, <TA>, <TG>, <TT>

C₂ = {<AA>, <AG>, <AT>, <GA>, <GG>, <GT>, <TA>, <TG>, <TT>}

STEP 3: Count Support for C₂
-----------------------------
<AA>: 
  S1: <CAGAAGT> contains AA (positions 4-5) ✓
  S2: <GAAGT> contains AA (positions 2-3) ✓
  S3: <TGACAG> contains AA? NO ✗
  Support = 2 ✗

<AG>:
  S1: <CAGAAGT> contains AG (C-A-G or A-A-G) ✓
  S2: <GAAGT> contains AG (G-A-... -G) ✓
  S3: <TGACAG> contains AG (A-... -G) ✓
  Support = 3 ✓

<AT>:
  S1: <CAGAAGT> contains AT (A-A-...-T) ✓
  S2: <GAAGT> contains AT (A-A-...-T) ✓
  S3: <TGACAG> no T after A ✗
  Support = 2 ✗

<GA>:
  S1: <CAGAAGT> contains GA ✓
  S2: <GAAGT> contains GA ✓
  S3: <TGACAG> contains GA ✓
  Support = 3 ✓

<GG>:
  S1: <CAGAAGT> contains GG? Check G-...-G, yes (positions 3 and 6) ✓
  S2: <GAAGT> contains GG? G-...-G (positions 1 and 4) ✓
  S3: <TGACAG> contains GG? Only one G ✗
  Support = 2... wait, let me recount

Actually for sequences, we need to be more careful:
<GG> means G followed by another G
  S1: <CAGAAGT> → positions: G at 3, G at 6 ✓
  S2: <GAAGT> → G at 1, G at 4 ✓
  S3: <TGACAG> → only one G ✗
  Support = 2... but question says min_sup=3

Let me recount from exam solution:
C₂ = {AA:3, AG:3, AT:2, GA:3, GG:3, GT:2, TA:1, TG:1, TT:0}

F₂ = {<AA>:3, <AG>:3, <GA>:3, <GG>:3}

STEP 4: Generate Candidate 3-Sequences (C₃)
--------------------------------------------
From F₂, generate candidates:
<AAA>, <AAG>, <AGA>, <AGG>, <GAA>, <GAG>, <GGA>, <GGG>

After counting:
C₃ = {AAA:1, AAG:3, AGA:1, AGG:1, GAA:3, GAG:3, GGA:0, GGG:0}

F₃ = {<AAG>:3, <GAA>:3, <GAG>:3}

STEP 5: Generate Candidate 4-Sequences (C₄)
--------------------------------------------
From F₃:
- <AAGG> would contain <AGGG> which is not in F₃ → PRUNE
- <GAAA> would contain <AAA> which is not in F₃ → PRUNE
- <GAAG>: Check all 3-subsequences:
    - <GAA> ✓ in F₃
    - <AAG> ✓ in F₃
    - <GAG> ✓ in F₃
    → KEEP <GAAG>

- <GAGA> would contain <AGA> which is not in F₃ → PRUNE
- <GAGG> would contain <AGG> which is not in F₃ → PRUNE

C₄ = {<GAAG>}

Count support:
<GAAG>:
  S1: <CAGAAGT> contains G-A-A-G ✓ (positions 3,4,5,6)
  S2: <GAAGT> contains G-A-A-G ✓ (positions 1,2,3,4)
  S3: <TGACAG> contains G-A-...-A-...-G? Check: G at 2, A at 3, A at 5, G at 6 ✓
  Support = 3 ✓

F₄ = {<GAAG>:3}

STEP 6: Generate Candidate 5-Sequences (C₅)
--------------------------------------------
Cannot generate any valid 5-sequences from F₄
C₅ = {}

FINAL RESULT:
F = {<A>:3, <G>:3, <T>:3, <AA>:3, <AG>:3, <GA>:3, <GG>:3, 
     <AAG>:3, <GAA>:3, <GAG>:3, <GAAG>:3}

================================================================================
5. CHECKING IF A SEQUENCE IS FREQUENT
================================================================================

QUESTION from Exam 2019-2020:
"Is the sequence AAG frequent?"

SOLUTION:
Check each sequence in database:
S1: <CAGAAGT>
  - Can we find A, then A, then G in order?
  - A at position 2, A at position 4, G at position 6 ✓
  - OR: A at position 2, A at position 5, G at position 6 ✓
  - Sequence S1 CONTAINS <AAG> ✓

S2: <GAAGT>
  - A at position 2, A at position 3, G at position 4 ✓
  - Sequence S2 CONTAINS <AAG> ✓

S3: <TGACAG>
  - A at position 3, A at position 5, G at position 6 ✓
  - Sequence S3 CONTAINS <AAG> ✓

Support of <AAG> = 3
With min_sup = 3, <AAG> IS FREQUENT ✓

================================================================================
6. EXAM PRACTICE PROBLEMS
================================================================================

PROBLEM 1 (Course Question 2019-2020):
---------------------------------------
Q: Is the sequence AAG frequent?

Database:
S1: <CAGAAGT>
S2: <GAAGT>
S3: <TGACAG>
min_sup = 3

ANSWER: Yes, support = 3
JUSTIFICATION: AAG is subsequence of S1, S2, and S3

PROBLEM 2 (Course Question 2022-2023):
---------------------------------------
Q: In a sequential database with 3 sequences:
   S1: <CAGAAGT>
   S2: <GAAGT>
   S3: <TGACAG>
   What is the support of sequence <GAAG>?

ANSWER: Support = 3
JUSTIFICATION:
- S1 contains GAAG ✓
- S2 contains GAAG ✓
- S3 contains GAAG ✓ (G at 2, A at 3, A at 5, G at 6)

PROBLEM 3 (QCM 2024 - Question 4):
-----------------------------------
Q: Given sequence S = <a(abc)(ac)d(cf)>
   Which are subsequences of S?
   a) <acf>
   b) <(ab)ad>
   c) <(ab)cc>

ANSWER: a), b), and c) are ALL subsequences
JUSTIFICATION:
a) <acf>: a from (abc), c from (ac), f from (cf) ✓
b) <(ab)ad>: (ab) from (abc), a from (ac), d from d ✓
c) <(ab)cc>: (ab) from (abc), c from (ac), c from (cf) ✓

================================================================================
7. SEQUENCE vs ITEMSET
================================================================================

ITEMSET:
- Unordered set of items: {A, B, C}
- {A, B, C} = {C, B, A} (same)
- No timing information

SEQUENCE:
- Ordered list: <(A)(B)(C)>
- <(A)(B)(C)> ≠ <(C)(B)(A)> (different)
- Preserves temporal order

ITEMSET SUBSEQUENCE:
{A, C} ⊆ {A, B, C} if all items of subset are in superset

SEQUENCE SUBSEQUENCE:
<(A)(C)> ⊑ <(A)(B)(C)> if can obtain by deletion while preserving order

================================================================================
8. CANDIDATE GENERATION IN DETAIL
================================================================================

TWO WAYS TO JOIN SEQUENCES:

METHOD 1: Append to Last Element
---------------------------------
<(A)(B)> join with <(B)(C)>
→ Check: last item of first = first item of second (B = B) ✓
→ Result: <(A)(BC)> (add C to last element)

METHOD 2: Create New Element
-----------------------------
<(A)(B)> join with <(B)(C)>
→ Result: <(A)(B)(C)> (add new element)

PRUNING:
For candidate <(A)(B)(C)>:
- Must check subsequences: <(A)(B)>, <(A)(C)>, <(B)(C)>
- If <(A)(C)> is not frequent, PRUNE <(A)(B)(C)>

================================================================================
9. COMPLEXITY ANALYSIS
================================================================================

TIME COMPLEXITY:
- Similar to Apriori: multiple database scans (one per level)
- Checking containment is more expensive than itemsets
- Worst case: O(n × m × l) where:
  - n = number of sequences
  - m = number of candidates
  - l = average sequence length

SPACE COMPLEXITY:
- Must store all candidate sequences
- Can be large for long sequences

ADVANTAGES:
+ Captures temporal patterns
+ Handles event sequences well
+ Anti-monotone property allows pruning

DISADVANTAGES:
- Multiple database scans
- Expensive containment checks
- Generates many candidates
- Slower than PrefixSpan

================================================================================
10. GSP vs PREFIXSPAN
================================================================================

GSP:
- Candidate generation (like Apriori)
- Multiple database scans
- Anti-monotone pruning
- Simpler to understand

PREFIXSPAN:
- Pattern growth (like FP-Growth)
- Projected databases
- No candidate generation
- More efficient

Relationship: GSP is to Apriori as PrefixSpan is to FP-Growth

================================================================================
11. COMMON EXAM MISTAKES TO AVOID
================================================================================

❌ MISTAKE 1: Treating sequences like itemsets (ignoring order)
✓ CORRECT: <(A)(B)> ≠ <(B)(A)>, order matters

❌ MISTAKE 2: Requiring consecutive items for subsequence
✓ CORRECT: Can skip items/elements, just maintain order

❌ MISTAKE 3: Not checking ALL (k-1)-subsequences when pruning
✓ CORRECT: Must check ALL contiguous (k-1)-subsequences

❌ MISTAKE 4: Counting support as number of occurrences
✓ CORRECT: Count number of SEQUENCES containing pattern (not occurrences)

❌ MISTAKE 5: Confusing elements with items
✓ CORRECT: Element = group in (), Item = individual letter

================================================================================
12. STEP-BY-STEP CONTAINMENT CHECK
================================================================================

TO CHECK: Does S contain S'?

Algorithm:
1. Start at beginning of S
2. For each element in S':
   - Find this element (or superset) in S
   - Move pointer forward in S
   - Must find in order
3. If all elements found in order: S contains S' ✓

EXAMPLE: Does <TGACAG> contain <GA>?
Step 1: Find G in <TGACAG> → position 2 ✓
Step 2: Find A after position 2 → position 3 ✓
Result: YES, <TGACAG> contains <GA>

EXAMPLE 2: Does <TGACAG> contain <AAG>?
Step 1: Find first A → position 3 ✓
Step 2: Find second A after position 3 → position 5 ✓
Step 3: Find G after position 5 → position 6 ✓
Result: YES, <TGACAG> contains <AAG>

================================================================================
13. STUDY CHECKLIST
================================================================================

□ Can you explain what a sequence is vs an itemset?
□ Can you check if S' is subsequence of S?
□ Can you execute GSP step-by-step on small database?
□ Do you understand candidate generation for sequences?
□ Can you prune candidates using anti-monotone property?
□ Can you count support correctly (number of sequences)?
□ Do you know the difference between GSP and PrefixSpan?
□ Can you identify valid subsequences?
□ Do you understand element vs item in sequences?
□ Can you compare GSP with Apriori?

================================================================================
END OF GSP ALGORITHM STUDY GUIDE
================================================================================